#include "VMatrix.h"
#include <algorithm>
#include <iostream>
#include <iomanip>
/******************************************************************************
 * 
 *  Virtual matrix class
 * 
 *****************************************************************************/


std::string VMatrix::toString(StorageT storage)
{
   std::string s;
   switch (storage) {
      case Zero:      s = "Zero";      break;
      case Diagonal:  s = "Diagonal";  break;
      case Banded:    s = "Banded";    break;
      case Striped:   s = "Striped";   break;
      case Dense:     s = "Dense";     break;
   }

   return s;
}


VMatrix& VMatrix::init(size_t const nRows, size_t const nCols, StorageT const storage)
{
   release();
   m_nRows   = nRows;
   m_nCols   = nCols;
   m_storage = storage;

   if (m_storage == Striped) {
      std::cerr << "WARNING: Invalid initialization for striped VMatrix" << std::endl;
   }else if (m_storage == Banded) {
      std::cerr << "WARNING: Invalid initialization for banded VMatrix" << std::endl;
   }

   return *this;
}


VMatrix& VMatrix::init(size_t const nRows, size_t const nCols, 
   std::vector<int> const& stripes)
{
   release();
   m_nRows   = nRows;
   m_nCols   = nCols;
   m_storage = Striped;
   m_stripes = stripes;

   return *this;
}

VMatrix& VMatrix::init(size_t const nRows, size_t const nCols, size_t const lbands, 
   size_t const ubands)
{
   release();
   m_nRows   = nRows;
   m_nCols   = nCols;
   m_storage = Banded;

   m_stripes.push_back(lbands);
   m_stripes.push_back(ubands);

   return *this;
}


void VMatrix::bind()
//std::shared_ptr<double> VMatrix::bind()
{
   release();
   size_t n(0);

   switch (m_storage) {
      case Zero:
         n = 1;
         break;
      case Diagonal:
         n = std::min(m_nRows,m_nCols);
         break;
      case Banded:
         n = m_nRows*(m_stripes[0]+m_stripes[1]+1);  // kl + ku +1
         std::cout << "allocating " << n << " elements for banded matrix" << std::endl;
         break;
      case Striped:
         n = std::min(m_nRows,m_nCols) * m_stripes.size();
         break;
      case Dense:
         n = m_nRows*m_nCols;
         break;
   }

   m_data = new double[n];

   //return std::make_shared(m_data);
}


void VMatrix::bind(Functor const& functor)
{
   bind();

   switch (m_storage) {
      case Zero:
         fillZero(functor);
         break;
      case Diagonal:
         fillDiagonal(functor);
         break;
      case Banded:
         fillBanded(functor);
         break;
      case Striped:
         fillStriped(functor);
         break;
      case Dense:
         fillDense(functor);
         break;
   }
}


void VMatrix::fillZero(Functor const& functor)
{
   // This represents a zero block matrix where the entries are not
   // explicitly stored.  To initialize a zero block matrix use
   // the appropriate storage type and the ZeroFunctor.
   m_data[0] = 0.0;
}


void VMatrix::fillDense(Functor const& functor)
{
   unsigned k(0);
   for (unsigned i = 0; i < m_nRows; ++i) {
       for (unsigned j = 0; j < m_nCols; ++j, ++k) {
           m_data[k] = functor(i,j); 
       }
   }
}


void VMatrix::fillBanded(Functor const& functor)
{
   int kl(m_stripes[0]);
   int ku(m_stripes[1]);
   int k;

   for (int i = 0; i < m_nRows; ++i) {
       int jmin = std::max(0,i-kl);
       int jmax = std::min((int)m_nCols,i+ku+1);
//     std::cout << "j range for i = " << i << " -> (" << jmin << "..." << jmax << ")" <<std::endl;
       for (int j = jmin ; j < jmax; ++j) {
           k = j-i+kl+i*(kl+ku+1);
//         std::cout << "setting "<< k<< " to " << functor(i,j) << std::endl;
           m_data[k] = functor(i,j);
       }
   }
}


void VMatrix::fillStriped(Functor const& functor)
{
   unsigned nStripes(m_stripes.size());
   unsigned m(std::min(m_nRows,m_nCols));

   for (unsigned k = 0; k < nStripes; ++k) {
       int offset(m_stripes[k]);
       if (offset < 0) {
          unsigned max(std::min(m_nRows + offset,m_nCols));
//        std::cout << "offset = " << offset << " running to " << max << std::endl;
          for (unsigned j = 0; j < max; ++j) {
/*
               std::cout << "  setting data = " << j + k*m<< " to " 
                         << functor(j-offset,j) << std::endl;
*/
              m_data[j + k*m] = functor(j-offset,j);
          }
       }else {
          unsigned max(std::min(m_nRows, m_nCols-offset));
 //       std::cout << "offset = " << offset << " running to " << max << std::endl;
          for (unsigned i = 0; i < max; ++i) {
/*
               std::cout << "  setting data = " << i + k*m << " to " 
                         << functor(i,i+offset) << std::endl;
*/
              m_data[i + k*m] = functor(i,i+offset);
          }
       } 
   }

/*
   for (int i = 0; i < nStripes*m; ++i) {
       std::cout << "striped data " << i << " "<< m_data[i]<< std::endl;
   }
*/
}


void VMatrix::fillDiagonal(Functor const& functor)
{
   unsigned m(std::min(m_nRows,m_nCols));
   for (unsigned i = 0; i < m; ++i) {
       m_data[i] = functor(i,i);
   }
}


void VMatrix::toDense()
{
   double* data = new double[m_nRows*m_nCols];

   unsigned k(0);
   for (unsigned i = 0; i < m_nRows; ++i) {
       for (unsigned j = 0; j < m_nCols; ++j, ++k) {
           data[k] = (*this)(i,j);
       }
   }  

   release();
   m_data = data;
   m_storage = Dense;
   m_stripes.clear();
}





double VMatrix::operator()(unsigned const i, unsigned const j) const
{
   double value(0.0);

   switch (m_storage) {
      case Zero:
         break;

      case Diagonal:
         if (i==j) {
            value = m_data[i];
         }
         break;

      case Banded: {
         int kl(m_stripes[0]);
         int ku(m_stripes[1]);
//       std::cout << "Access element: (" << i << "," << j << ") -> ";
         if (std::max(0,(int)i-kl) <= j && j <= std::min((int)m_nCols,(int)i+ku)) {
            int k(j-i+kl+i*(kl+ku+1));
            value = m_data[k];
//          std::cout <<  k << " = ";
         }
//       std::cout <<  value << std::endl;
      } break;

      case Striped: {
         int stripe(j-i);
         std::vector<int>::const_iterator it;
         it = std::find(m_stripes.begin(), m_stripes.end(), stripe);

         if (it != m_stripes.end()) {
            // We have hit a non-zero element
            unsigned m(std::min(m_nRows,m_nCols));
            unsigned index = std::distance(m_stripes.begin(), it);
            int ij = (stripe < 0) ? j : i;
            value = m_data[ij + index*m];
         }

         } break;

      case Dense:
         value = m_data[i*m_nCols + j];
         break;
   }

   return value;
}


void VMatrix::set(unsigned const i, unsigned const j, double value)
{
   switch (m_storage) {
      case Zero:
         break;

      case Diagonal:
         if (i==j) {
            m_data[i] = value;
         }
         break;

      case Banded:
        std::cerr << "VMatrix::set NYI for Banded matrices" << std::endl;
        break;

      case Striped: {
         int stripe(j-i);
         std::vector<int>::iterator it;
         it = std::find(m_stripes.begin(), m_stripes.end(), stripe);

         if (it != m_stripes.end()) {
            // We have hit a non-zero element
            unsigned m(std::min(m_nRows,m_nCols));
            unsigned index = std::distance(m_stripes.begin(), it);
            int ij = (stripe < 0) ? j : i;
            m_data[ij + index*m] = value;
         }

         } break;

      case Dense:
         m_data[i*m_nCols + j] = value;
         break;
   }
}


void VMatrix::print(const char* msg) const
{
   if (msg) {
      std::cout << msg << std::endl;
   }
   for (unsigned i = 0; i < m_nRows; ++i) {
       for (unsigned j = 0; j < m_nCols; ++j) {
           std::cout << std::setw(5) << (*this)(i,j) << " ";
       }
       std::cout << std::endl;
   }
   std::cout << std::endl;
}
